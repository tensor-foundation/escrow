/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

export const enum TensorMarginProgramErrorCode {
  /** InvalidProof: invalid merkle proof, token not whitelisted */
  INVALID_PROOF = 0x1770, // 6000
  /** WhitelistNotVerified: whitelist not verified -- currently only verified pools supported */
  WHITELIST_NOT_VERIFIED = 0x1771, // 6001
  /** BadWhitelist: unexpected whitelist address */
  BAD_WHITELIST = 0x1772, // 6002
  /** WrongPoolType: operation not permitted on this pool type */
  WRONG_POOL_TYPE = 0x1773, // 6003
  /** BadFeeAccount: fee account doesn't match that stored on pool */
  BAD_FEE_ACCOUNT = 0x1774, // 6004
  /** BadEscrowAccount: escrow account doesn't match that stored on pool */
  BAD_ESCROW_ACCOUNT = 0x1775, // 6005
  /** MissingFees: when setting up a Trade pool, must provide fee bps & fee vault */
  MISSING_FEES = 0x1776, // 6006
  /** FeesTooHigh: fees entered above allowed threshold */
  FEES_TOO_HIGH = 0x1777, // 6007
  /** DeltaTooLarge: delta too large */
  DELTA_TOO_LARGE = 0x1778, // 6008
  /** ArithmeticError: arithmetic error */
  ARITHMETIC_ERROR = 0x1779, // 6009
  /** WrongPool: this nft doesnt belong to this pool */
  WRONG_POOL = 0x177a, // 6010
  /** RoyaltiesEnabled: royalties are enabled always */
  ROYALTIES_ENABLED = 0x177b, // 6011
  /** PriceMismatch: specified price not within current price */
  PRICE_MISMATCH = 0x177c, // 6012
  /** ExistingNfts: cannot close pool with nfts in escrow -- withdraw all before closing */
  EXISTING_NFTS = 0x177d, // 6013
  /** WrongMint: wrong mint passed for provided accounts */
  WRONG_MINT = 0x177e, // 6014
  /** InsufficientTswapAccBalance: insufficient Tswap account balance */
  INSUFFICIENT_TSWAP_ACC_BALANCE = 0x177f, // 6015
  /** BadOwner: bad owner */
  BAD_OWNER = 0x1780, // 6016
  /** FeesNotAllowed: fees not allowed for non-trade pools */
  FEES_NOT_ALLOWED = 0x1781, // 6017
  /** BadMetadata: metadata account does not match */
  BAD_METADATA = 0x1782, // 6018
  /** CreatorMismatch: provided creator address does not match metadata creator */
  CREATOR_MISMATCH = 0x1783, // 6019
  /** WrongPoolVersion: wrong pool version provided */
  WRONG_POOL_VERSION = 0x1784, // 6020
  /** PoolsAreTheSame: new pool should not match old pool */
  POOLS_ARE_THE_SAME = 0x1785, // 6021
  /** WrongAuthority: wrong nft authority account provided */
  WRONG_AUTHORITY = 0x1786, // 6022
  /** FrozenAmountMismatch: amount frozen doesnt match current price */
  FROZEN_AMOUNT_MISMATCH = 0x1787, // 6023
  /** BadMintProof: mint proof account does not match */
  BAD_MINT_PROOF = 0x1788, // 6024
  /** BadCosigner: bad cosigner passed - either wrong key or no signature */
  BAD_COSIGNER = 0x1789, // 6025
  /** PoolFrozen: pool is frozen and cannot execute normal operations */
  POOL_FROZEN = 0x178a, // 6026
  /** BadMargin: bad margin account passed */
  BAD_MARGIN = 0x178b, // 6027
  /** PoolNotMarginated: expected a marginated pool to be passed in */
  POOL_NOT_MARGINATED = 0x178c, // 6028
  /** PoolMarginated: expected a non-marginated pool to be passed in */
  POOL_MARGINATED = 0x178d, // 6029
  /** WrongOrderType: wrong order type */
  WRONG_ORDER_TYPE = 0x178e, // 6030
  /** WrongFrozenStatus: wrong frozen status */
  WRONG_FROZEN_STATUS = 0x178f, // 6031
  /** MarginInUse: margin account has pools open and is in use */
  MARGIN_IN_USE = 0x1790, // 6032
  /** MaxTakerSellCountExceeded: max taker sell count exceeded, pool cannot buy anymore NFTs */
  MAX_TAKER_SELL_COUNT_EXCEEDED = 0x1791, // 6033
  /** MaxTakerSellCountTooSmall: max taker sell count is too small */
  MAX_TAKER_SELL_COUNT_TOO_SMALL = 0x1792, // 6034
  /** BadRuleSet: rule set for programmable nft does not match */
  BAD_RULE_SET = 0x1793, // 6035
  /** PoolFeesCompounded: this pool compounds fees and they cannot be withdrawn separately */
  POOL_FEES_COMPOUNDED = 0x1794, // 6036
  /** BadRoyaltiesPct: royalties percentage passed in must be between 0 and 100 */
  BAD_ROYALTIES_PCT = 0x1795, // 6037
  /** StartingPriceTooSmall: starting price can't be smaller than 1 lamport */
  STARTING_PRICE_TOO_SMALL = 0x1796, // 6038
}

export class TensorMarginProgramError extends Error {
  override readonly name = 'TensorMarginProgramError';

  readonly code: TensorMarginProgramErrorCode;

  readonly cause: Error | undefined;

  constructor(
    code: TensorMarginProgramErrorCode,
    name: string,
    message: string,
    cause?: Error
  ) {
    super(`${name} (${code}): ${message}`);
    this.code = code;
    this.cause = cause;
  }
}

let tensorMarginProgramErrorCodeMap:
  | Record<TensorMarginProgramErrorCode, [string, string]>
  | undefined;
if (__DEV__) {
  tensorMarginProgramErrorCodeMap = {
    [TensorMarginProgramErrorCode.INVALID_PROOF]: [
      'InvalidProof',
      `invalid merkle proof, token not whitelisted`,
    ],
    [TensorMarginProgramErrorCode.WHITELIST_NOT_VERIFIED]: [
      'WhitelistNotVerified',
      `whitelist not verified -- currently only verified pools supported`,
    ],
    [TensorMarginProgramErrorCode.BAD_WHITELIST]: [
      'BadWhitelist',
      `unexpected whitelist address`,
    ],
    [TensorMarginProgramErrorCode.WRONG_POOL_TYPE]: [
      'WrongPoolType',
      `operation not permitted on this pool type`,
    ],
    [TensorMarginProgramErrorCode.BAD_FEE_ACCOUNT]: [
      'BadFeeAccount',
      `fee account doesn't match that stored on pool`,
    ],
    [TensorMarginProgramErrorCode.BAD_ESCROW_ACCOUNT]: [
      'BadEscrowAccount',
      `escrow account doesn't match that stored on pool`,
    ],
    [TensorMarginProgramErrorCode.MISSING_FEES]: [
      'MissingFees',
      `when setting up a Trade pool, must provide fee bps & fee vault`,
    ],
    [TensorMarginProgramErrorCode.FEES_TOO_HIGH]: [
      'FeesTooHigh',
      `fees entered above allowed threshold`,
    ],
    [TensorMarginProgramErrorCode.DELTA_TOO_LARGE]: [
      'DeltaTooLarge',
      `delta too large`,
    ],
    [TensorMarginProgramErrorCode.ARITHMETIC_ERROR]: [
      'ArithmeticError',
      `arithmetic error`,
    ],
    [TensorMarginProgramErrorCode.WRONG_POOL]: [
      'WrongPool',
      `this nft doesnt belong to this pool`,
    ],
    [TensorMarginProgramErrorCode.ROYALTIES_ENABLED]: [
      'RoyaltiesEnabled',
      `royalties are enabled always`,
    ],
    [TensorMarginProgramErrorCode.PRICE_MISMATCH]: [
      'PriceMismatch',
      `specified price not within current price`,
    ],
    [TensorMarginProgramErrorCode.EXISTING_NFTS]: [
      'ExistingNfts',
      `cannot close pool with nfts in escrow -- withdraw all before closing`,
    ],
    [TensorMarginProgramErrorCode.WRONG_MINT]: [
      'WrongMint',
      `wrong mint passed for provided accounts`,
    ],
    [TensorMarginProgramErrorCode.INSUFFICIENT_TSWAP_ACC_BALANCE]: [
      'InsufficientTswapAccBalance',
      `insufficient Tswap account balance`,
    ],
    [TensorMarginProgramErrorCode.BAD_OWNER]: ['BadOwner', `bad owner`],
    [TensorMarginProgramErrorCode.FEES_NOT_ALLOWED]: [
      'FeesNotAllowed',
      `fees not allowed for non-trade pools`,
    ],
    [TensorMarginProgramErrorCode.BAD_METADATA]: [
      'BadMetadata',
      `metadata account does not match`,
    ],
    [TensorMarginProgramErrorCode.CREATOR_MISMATCH]: [
      'CreatorMismatch',
      `provided creator address does not match metadata creator`,
    ],
    [TensorMarginProgramErrorCode.WRONG_POOL_VERSION]: [
      'WrongPoolVersion',
      `wrong pool version provided`,
    ],
    [TensorMarginProgramErrorCode.POOLS_ARE_THE_SAME]: [
      'PoolsAreTheSame',
      `new pool should not match old pool`,
    ],
    [TensorMarginProgramErrorCode.WRONG_AUTHORITY]: [
      'WrongAuthority',
      `wrong nft authority account provided`,
    ],
    [TensorMarginProgramErrorCode.FROZEN_AMOUNT_MISMATCH]: [
      'FrozenAmountMismatch',
      `amount frozen doesnt match current price`,
    ],
    [TensorMarginProgramErrorCode.BAD_MINT_PROOF]: [
      'BadMintProof',
      `mint proof account does not match`,
    ],
    [TensorMarginProgramErrorCode.BAD_COSIGNER]: [
      'BadCosigner',
      `bad cosigner passed - either wrong key or no signature`,
    ],
    [TensorMarginProgramErrorCode.POOL_FROZEN]: [
      'PoolFrozen',
      `pool is frozen and cannot execute normal operations`,
    ],
    [TensorMarginProgramErrorCode.BAD_MARGIN]: [
      'BadMargin',
      `bad margin account passed`,
    ],
    [TensorMarginProgramErrorCode.POOL_NOT_MARGINATED]: [
      'PoolNotMarginated',
      `expected a marginated pool to be passed in`,
    ],
    [TensorMarginProgramErrorCode.POOL_MARGINATED]: [
      'PoolMarginated',
      `expected a non-marginated pool to be passed in`,
    ],
    [TensorMarginProgramErrorCode.WRONG_ORDER_TYPE]: [
      'WrongOrderType',
      `wrong order type`,
    ],
    [TensorMarginProgramErrorCode.WRONG_FROZEN_STATUS]: [
      'WrongFrozenStatus',
      `wrong frozen status`,
    ],
    [TensorMarginProgramErrorCode.MARGIN_IN_USE]: [
      'MarginInUse',
      `margin account has pools open and is in use`,
    ],
    [TensorMarginProgramErrorCode.MAX_TAKER_SELL_COUNT_EXCEEDED]: [
      'MaxTakerSellCountExceeded',
      `max taker sell count exceeded, pool cannot buy anymore NFTs`,
    ],
    [TensorMarginProgramErrorCode.MAX_TAKER_SELL_COUNT_TOO_SMALL]: [
      'MaxTakerSellCountTooSmall',
      `max taker sell count is too small`,
    ],
    [TensorMarginProgramErrorCode.BAD_RULE_SET]: [
      'BadRuleSet',
      `rule set for programmable nft does not match`,
    ],
    [TensorMarginProgramErrorCode.POOL_FEES_COMPOUNDED]: [
      'PoolFeesCompounded',
      `this pool compounds fees and they cannot be withdrawn separately`,
    ],
    [TensorMarginProgramErrorCode.BAD_ROYALTIES_PCT]: [
      'BadRoyaltiesPct',
      `royalties percentage passed in must be between 0 and 100`,
    ],
    [TensorMarginProgramErrorCode.STARTING_PRICE_TOO_SMALL]: [
      'StartingPriceTooSmall',
      `starting price can't be smaller than 1 lamport`,
    ],
  };
}

export function getTensorMarginProgramErrorFromCode(
  code: TensorMarginProgramErrorCode,
  cause?: Error
): TensorMarginProgramError {
  if (__DEV__) {
    return new TensorMarginProgramError(
      code,
      ...(
        tensorMarginProgramErrorCodeMap as Record<
          TensorMarginProgramErrorCode,
          [string, string]
        >
      )[code],
      cause
    );
  }

  return new TensorMarginProgramError(
    code,
    'Unknown',
    'Error message not available in production bundles. Compile with __DEV__ set to true to see more information.',
    cause
  );
}
