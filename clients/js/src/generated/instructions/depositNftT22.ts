/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import { Address } from '@solana/addresses';
import {
  Codec,
  Decoder,
  Encoder,
  combineCodec,
  getArrayDecoder,
  getArrayEncoder,
  getStructDecoder,
  getStructEncoder,
  getU8Decoder,
  getU8Encoder,
  mapEncoder,
} from '@solana/codecs';
import {
  IAccountMeta,
  IInstruction,
  IInstructionWithAccounts,
  IInstructionWithData,
  ReadonlyAccount,
  WritableAccount,
  WritableSignerAccount,
} from '@solana/instructions';
import { IAccountSignerMeta, TransactionSigner } from '@solana/signers';
import { TENSOR_ESCROW_PROGRAM_ADDRESS } from '../programs';
import { ResolvedAccount, getAccountMetaFactory } from '../shared';
import {
  PoolConfig,
  PoolConfigArgs,
  getPoolConfigDecoder,
  getPoolConfigEncoder,
} from '../types';

export type DepositNftT22Instruction<
  TProgram extends string = typeof TENSOR_ESCROW_PROGRAM_ADDRESS,
  TAccountTswap extends string | IAccountMeta<string> = string,
  TAccountPool extends string | IAccountMeta<string> = string,
  TAccountWhitelist extends string | IAccountMeta<string> = string,
  TAccountNftSource extends string | IAccountMeta<string> = string,
  TAccountNftMint extends string | IAccountMeta<string> = string,
  TAccountNftEscrow extends string | IAccountMeta<string> = string,
  TAccountNftReceipt extends string | IAccountMeta<string> = string,
  TAccountOwner extends string | IAccountMeta<string> = string,
  TAccountTokenProgram extends
    | string
    | IAccountMeta<string> = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  TAccountSystemProgram extends
    | string
    | IAccountMeta<string> = '11111111111111111111111111111111',
  TAccountMintProof extends string | IAccountMeta<string> = string,
  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<
    [
      TAccountTswap extends string
        ? ReadonlyAccount<TAccountTswap>
        : TAccountTswap,
      TAccountPool extends string
        ? WritableAccount<TAccountPool>
        : TAccountPool,
      TAccountWhitelist extends string
        ? ReadonlyAccount<TAccountWhitelist>
        : TAccountWhitelist,
      TAccountNftSource extends string
        ? WritableAccount<TAccountNftSource>
        : TAccountNftSource,
      TAccountNftMint extends string
        ? ReadonlyAccount<TAccountNftMint>
        : TAccountNftMint,
      TAccountNftEscrow extends string
        ? WritableAccount<TAccountNftEscrow>
        : TAccountNftEscrow,
      TAccountNftReceipt extends string
        ? WritableAccount<TAccountNftReceipt>
        : TAccountNftReceipt,
      TAccountOwner extends string
        ? WritableSignerAccount<TAccountOwner> &
            IAccountSignerMeta<TAccountOwner>
        : TAccountOwner,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      TAccountMintProof extends string
        ? ReadonlyAccount<TAccountMintProof>
        : TAccountMintProof,
      ...TRemainingAccounts,
    ]
  >;

export type DepositNftT22InstructionData = {
  discriminator: Array<number>;
  config: PoolConfig;
};

export type DepositNftT22InstructionDataArgs = { config: PoolConfigArgs };

export function getDepositNftT22InstructionDataEncoder(): Encoder<DepositNftT22InstructionDataArgs> {
  return mapEncoder(
    getStructEncoder([
      ['discriminator', getArrayEncoder(getU8Encoder(), { size: 8 })],
      ['config', getPoolConfigEncoder()],
    ]),
    (value) => ({
      ...value,
      discriminator: [208, 34, 6, 147, 95, 218, 49, 160],
    })
  );
}

export function getDepositNftT22InstructionDataDecoder(): Decoder<DepositNftT22InstructionData> {
  return getStructDecoder([
    ['discriminator', getArrayDecoder(getU8Decoder(), { size: 8 })],
    ['config', getPoolConfigDecoder()],
  ]);
}

export function getDepositNftT22InstructionDataCodec(): Codec<
  DepositNftT22InstructionDataArgs,
  DepositNftT22InstructionData
> {
  return combineCodec(
    getDepositNftT22InstructionDataEncoder(),
    getDepositNftT22InstructionDataDecoder()
  );
}

export type DepositNftT22Input<
  TAccountTswap extends string = string,
  TAccountPool extends string = string,
  TAccountWhitelist extends string = string,
  TAccountNftSource extends string = string,
  TAccountNftMint extends string = string,
  TAccountNftEscrow extends string = string,
  TAccountNftReceipt extends string = string,
  TAccountOwner extends string = string,
  TAccountTokenProgram extends string = string,
  TAccountSystemProgram extends string = string,
  TAccountMintProof extends string = string,
> = {
  tswap: Address<TAccountTswap>;
  pool: Address<TAccountPool>;
  /** Needed for pool seeds derivation, also checked via has_one on pool */
  whitelist: Address<TAccountWhitelist>;
  nftSource: Address<TAccountNftSource>;
  nftMint: Address<TAccountNftMint>;
  nftEscrow: Address<TAccountNftEscrow>;
  nftReceipt: Address<TAccountNftReceipt>;
  owner: TransactionSigner<TAccountOwner>;
  tokenProgram?: Address<TAccountTokenProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  mintProof: Address<TAccountMintProof>;
  config: DepositNftT22InstructionDataArgs['config'];
};

export function getDepositNftT22Instruction<
  TAccountTswap extends string,
  TAccountPool extends string,
  TAccountWhitelist extends string,
  TAccountNftSource extends string,
  TAccountNftMint extends string,
  TAccountNftEscrow extends string,
  TAccountNftReceipt extends string,
  TAccountOwner extends string,
  TAccountTokenProgram extends string,
  TAccountSystemProgram extends string,
  TAccountMintProof extends string,
>(
  input: DepositNftT22Input<
    TAccountTswap,
    TAccountPool,
    TAccountWhitelist,
    TAccountNftSource,
    TAccountNftMint,
    TAccountNftEscrow,
    TAccountNftReceipt,
    TAccountOwner,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountMintProof
  >
): DepositNftT22Instruction<
  typeof TENSOR_ESCROW_PROGRAM_ADDRESS,
  TAccountTswap,
  TAccountPool,
  TAccountWhitelist,
  TAccountNftSource,
  TAccountNftMint,
  TAccountNftEscrow,
  TAccountNftReceipt,
  TAccountOwner,
  TAccountTokenProgram,
  TAccountSystemProgram,
  TAccountMintProof
> {
  // Program address.
  const programAddress = TENSOR_ESCROW_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    tswap: { value: input.tswap ?? null, isWritable: false },
    pool: { value: input.pool ?? null, isWritable: true },
    whitelist: { value: input.whitelist ?? null, isWritable: false },
    nftSource: { value: input.nftSource ?? null, isWritable: true },
    nftMint: { value: input.nftMint ?? null, isWritable: false },
    nftEscrow: { value: input.nftEscrow ?? null, isWritable: true },
    nftReceipt: { value: input.nftReceipt ?? null, isWritable: true },
    owner: { value: input.owner ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
    mintProof: { value: input.mintProof ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenProgram.value) {
    accounts.tokenProgram.value =
      'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.tswap),
      getAccountMeta(accounts.pool),
      getAccountMeta(accounts.whitelist),
      getAccountMeta(accounts.nftSource),
      getAccountMeta(accounts.nftMint),
      getAccountMeta(accounts.nftEscrow),
      getAccountMeta(accounts.nftReceipt),
      getAccountMeta(accounts.owner),
      getAccountMeta(accounts.tokenProgram),
      getAccountMeta(accounts.systemProgram),
      getAccountMeta(accounts.mintProof),
    ],
    programAddress,
    data: getDepositNftT22InstructionDataEncoder().encode(
      args as DepositNftT22InstructionDataArgs
    ),
  } as DepositNftT22Instruction<
    typeof TENSOR_ESCROW_PROGRAM_ADDRESS,
    TAccountTswap,
    TAccountPool,
    TAccountWhitelist,
    TAccountNftSource,
    TAccountNftMint,
    TAccountNftEscrow,
    TAccountNftReceipt,
    TAccountOwner,
    TAccountTokenProgram,
    TAccountSystemProgram,
    TAccountMintProof
  >;

  return instruction;
}

export type ParsedDepositNftT22Instruction<
  TProgram extends string = typeof TENSOR_ESCROW_PROGRAM_ADDRESS,
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    tswap: TAccountMetas[0];
    pool: TAccountMetas[1];
    /** Needed for pool seeds derivation, also checked via has_one on pool */
    whitelist: TAccountMetas[2];
    nftSource: TAccountMetas[3];
    nftMint: TAccountMetas[4];
    nftEscrow: TAccountMetas[5];
    nftReceipt: TAccountMetas[6];
    owner: TAccountMetas[7];
    tokenProgram: TAccountMetas[8];
    systemProgram: TAccountMetas[9];
    mintProof: TAccountMetas[10];
  };
  data: DepositNftT22InstructionData;
};

export function parseDepositNftT22Instruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>
): ParsedDepositNftT22Instruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 11) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      tswap: getNextAccount(),
      pool: getNextAccount(),
      whitelist: getNextAccount(),
      nftSource: getNextAccount(),
      nftMint: getNextAccount(),
      nftEscrow: getNextAccount(),
      nftReceipt: getNextAccount(),
      owner: getNextAccount(),
      tokenProgram: getNextAccount(),
      systemProgram: getNextAccount(),
      mintProof: getNextAccount(),
    },
    data: getDepositNftT22InstructionDataDecoder().decode(instruction.data),
  };
}
